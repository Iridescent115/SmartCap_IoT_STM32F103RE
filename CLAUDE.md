# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is an **IoT Gateway** built around STM32F103RE (ARM Cortex-M3, 72MHz, 512KB Flash) that bridges RS485-based industrial devices to 4G cellular networks for remote monitoring and control.

**Data Flow:**
```
Industrial Devices (RS485) <-> STM32 <-> RG200U (4G) <-> Internet -> Remote TCP Server
```

## Build Commands

### Building with STM32CubeIDE
```bash
# Open the project file
Firmware/SmartCap_IoT_STM32F103RE/SmartCap_IoT_STM32F103RE.ioc
# Then build using the IDE's Project > Build Project
```

### Building with Keil MDK-ARM
```bash
# Open the project file
Firmware/SmartCap_IoT_STM32F103RE/MDK-ARM/SmartCap_IoT_STM32F103RE.uvprojx
# Then build using Project > Build (F7)
```

## Architecture

### Hardware Interfaces
| Interface | Function | Pins |
|-----------|----------|------|
| USART1 | RS485 with MAX13487 transceiver | PB6/TX, PB7/RX, PB5/RE#, PA15/SHDN# |
| UART5 | RG200U 4G module | 通信引脚 |
| SPI2 | W5500 Ethernet controller (not currently active) | - |
| TIM2 | W5500 timer interrupt handler | - |

### FreeRTOS Task Structure
The system uses 5 FreeRTOS tasks with priority-based scheduling:

| Task | Priority | Stack | Function |
|------|----------|-------|----------|
| `DefaultTask` | Low (-2) | 128 words | System monitoring, LED indication |
| `RS485_RxTask` | AboveNormal (1) | 512 words | RS485 data reception |
| `RG200U_RxTask` | AboveNormal (1) | 512 words | 4G module data reception |
| `RS485_TxTask` | Normal (0) | 512 words | RS485 transmission with direction control |
| `RG200U_TxTask` | Normal (0) | 512 words | 4G module data transmission |

### Inter-Task Communication
- `Queue_RS485_To_RG200U`: 256-byte buffer for RS485 → 4G data flow
- `Queue_RG200U_To_RS485`: 256-byte buffer for 4G → RS485 data flow

## Key Source Files

### User Application Code (`User/user_main/`)
- `user_main.c/h`: Entry point `User_main()` called from `main.c`
- `rs485.c/h`: RS485 communication module with interrupt-driven ring buffer reception
- `rg200u.c/h`: RG200U 4G module driver with TCP client functionality
- `user_tasks.c/h`: FreeRTOS task implementations

### WIZnet Ethernet Support (`User/wiz_interface/`, `User/wiz_platform/`)
- W5500 Ethernet controller support exists but is not currently active
- TIM2 configured for WIZnet timer interrupts (`wiz_timer_handler()`)

### Generated Code (`Core/`)
- `main.c`: Generated by STM32CubeMX, calls `User_main()` in USER CODE section
- `freertos.c`: FreeRTOS initialization with task definitions
- `stm32f1xx_it.c`: Interrupt handlers, includes `HAL_UART_RxCpltCallback()` for UART callbacks

## Important Design Patterns

### RS485 Reception Pattern
RS485 uses **interrupt-driven reception with ring buffer** (fixed in RS485_RX_BUG_FIX.md):
1. `HAL_UART_Receive_IT(&huart1, &rs485_uart_rx_byte, 1)` starts reception
2. `RS485_UART_RxCallback()` in `stm32f1xx_it.c` writes to ring buffer
3. `RS485_ReceiveByte()` reads from ring buffer (non-blocking)

**When implementing new UART communication:** Follow the same pattern as RS485 - use interrupt reception with ring buffer, never poll hardware registers directly.

### CubeMX Code Integration
The project separates CubeMX-generated code from user code:
- CubeMX-generated files (Core/, MDK-ARM/) can be regenerated
- User code in `User/user_main/` is never affected by regeneration
- Use `USER CODE BEGIN/END` sections in generated files for customizations

### UART Callback Registration
In `stm32f1xx_it.c`, `HAL_UART_RxCpltCallback()` routes UART interrupts:
```c
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == UART5) {
        RG200U_UART_RxCallback();
    } else if (huart->Instance == USART1) {
        RS485_UART_RxCallback();
    }
}
```
**When adding a new UART:** Add a branch here to route to the appropriate callback.

## Configuration

### TCP Server Connection
Edit `User/user_main/rg200u.h`:
```c
#define TCP_SERVER_IP    "8.135.10.183"  // Server IPv4 address
#define TCP_SERVER_PORT  "35814"          // Server port
#define TCP_SOCKET_ID    0                // Socket ID
```

### Debug Output
Edit `User/user_main/rg200u.h`:
```c
#define RG200U_DEBUG_ENABLE     0  // 1=enable debug, 0=disable
```

### FreeRTOS Configuration
Edit `Core/Inc/FreeRTOSConfig.h`:
- `configTOTAL_HEAP_SIZE`: 10KB (10240 bytes)
- `configTICK_RATE_HZ`: 1000 (1ms tick)
- `configMAX_PRIORITIES`: 5 priority levels

## Known Issues & Solutions

### RS485 Reception Fixed
Originally, RS485 used polling of hardware registers (`USART1->SR & USART_SR_RXNE`) which caused data loss. Fixed by:
1. Adding 256-byte ring buffer
2. Starting interrupt reception in `RS485_Init()`
3. Implementing `RS485_UART_RxCallback()` to fill buffer
4. Rewriting `RS485_ReceiveByte()` to read from buffer

See `Docs/RS485_RX_BUG_FIX.md` for details.

### IPv6 NAT Limitations
China Unicom's 4G network provides public IPv6 addresses but with NAT/firewall restrictions preventing inbound connections. The system is designed as a TCP client that connects to a remote server.

## Documentation

- `Docs/TCP_IPv6_USAGE.md`: TCP/IPv6 communication usage guide
- `Docs/RS485_RX_BUG_FIX.md`: Detailed RS485 reception fix
- `Docs/IPv6_NAT_Test_Guide.md`: IPv6 NAT testing guide
- `Docs/RG200U_AT_Commands_Manual_Test.md`: AT command testing
- `Docs/年前工作进度.md`: Work progress summary

## Code Layout

```
Firmware/SmartCap_IoT_STM32F103RE/
├── Core/              # STM32CubeMX generated code
│   ├── Src/           # Source files (main.c, freertos.c, etc.)
│   └── Inc/           # Header files
├── MDK-ARM/           # Keil project files
├── User/              # User application code (preserved on regen)
│   ├── user_main/     # Main application logic
│   ├── wiz_interface/ # WIZnet interface layer
│   ├── wiz_platform/  # WIZnet platform-specific code
│   └── ioLibrary_Driver/  # WIZnet driver library
└── SmartCap_IoT_STM32F103RE.ioc  # CubeMX project file

Docs/                  # Documentation
```
